# 除自身以外数组的乘积（LeetCode 238）

## 1. 题目归类
- **数据结构**：数组
- **算法思想**：前缀积、双指针
- **题型标签**：数组、前缀积

## 2. 思路分析

### 暴力思路
对于每个元素，计算除它之外所有元素的乘积。

**问题**：
- 时间复杂度 O(n²)，效率低
- 计算量太大

### 优化思路：前缀积
使用前缀积和后缀积。

**关键观察**：
- 对于位置 i，结果 = (i 左边所有数的乘积) × (i 右边所有数的乘积)
- 可以预先计算前缀积数组和后缀积数组
- 前缀积：left[i] 表示 nums[0] × nums[1] × ... × nums[i-1]
- 后缀积：right[i] 表示 nums[i+1] × nums[i+2] × ... × nums[n-1]
- 结果：result[i] = left[i] × right[i]

**进一步优化空间**：
- 不需要两个数组，可以使用结果数组存储前缀积
- 再用一个变量维护后缀积

**为什么有效**：
- 将 O(n²) 的问题转化为 O(n)
- 利用乘法的结合律和交换律

### 边界考虑
- 数组长度为 1
- 数组中包含 0
- 数组中包含多个 0
- 数组中包含负数

## 3. 解法实现（Java）

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        
        // 计算前缀积
        result[0] = 1;
        for (int i = 1; i < n; i++) {
            result[i] = result[i - 1] * nums[i - 1];
        }
        
        // 计算后缀积并更新结果
        int suffix = 1;
        for (int i = n - 1; i >= 0; i--) {
            result[i] = result[i] * suffix;
            suffix *= nums[i];
        }
        
        return result;
    }
}
```

## 4. 复杂度分析

- **时间复杂度**：O(n)
  - 遍历两次数组

- **空间复杂度**：O(1)（不包括输出数组）
  - 只使用了常数空间
  - 如果考虑输出数组，则为 O(n)

## 5. 易错点

1. **边界条件**
   - 第一个元素没有左边元素，前缀积为 1
   - 最后一个元素没有右边元素，后缀积为 1

2. **包含 0 的情况**
   - 如果数组中只有一个 0，除 0 以外的位置结果为 0
   - 如果数组中有两个或更多 0，所有位置结果都为 0
   - 算法会自动处理这种情况

3. **更新顺序**
   - 第二次遍历是从后往前
   - 先使用后缀积更新结果，再更新后缀积变量

4. **不能使用除法**
   - 题目要求不能使用除法
   - 如果没有这个限制，可以先算总乘积，再除以每个元素

## 6. 模板沉淀

### 模板：前缀和/积

**适用场景**：
- 需要计算区间和/积
- 需要知道某个位置之前或之后的信息
- 需要避免重复计算

**模板代码**：

```java
public int[] prefixSum(int[] nums) {
    int n = nums.length;
    int[] prefix = new int[n + 1];
    
    for (int i = 0; i < n; i++) {
        prefix[i + 1] = prefix[i] + nums[i];
    }
    
    return prefix;
}
```

**使用前缀和计算区间和**：
```java
// 区间 [l, r] 的和 = prefix[r + 1] - prefix[l]
int rangeSum(int[] prefix, int l, int r) {
    return prefix[r + 1] - prefix[l];
}
```

**适用题目**：
- 除自身以外数组的乘积
- 区间和查询
- 连续子数组的最大和
- 和为 K 的子数组

**扩展**：
- 前缀和可以扩展到二维（子矩阵和）
- 可以结合哈希表解决特定问题
