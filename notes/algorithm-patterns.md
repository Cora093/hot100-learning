# 算法模式总结

本文档记录 LeetCode Hot100 中的常见算法模式与解题模板。

## 目录

- [数组与字符串](#数组与字符串)
- [双指针与滑动窗口](#双指针与滑动窗口)
- [哈希表](#哈希表)
- [链表](#链表)
- [栈与队列](#栈与队列)
- [二叉树](#二叉树)
- [二分查找](#二分查找)
- [贪心算法](#贪心算法)
- [回溯算法](#回溯算法)
- [动态规划](#动态规划)

---

## 数组与字符串

### 模式1：原地修改数组

**适用场景**：需要在原数组上修改元素顺序或值

**关键点**：
- 使用双指针，一个用于遍历，一个用于标记修改位置
- 注意数组长度的变化

**模板**：

```java
int slow = 0;
for (int fast = 0; fast < nums.length; fast++) {
    if (满足条件) {
        nums[slow] = nums[fast];
        slow++;
    }
}
return slow;
```

### 模式2：二维数组遍历

**适用场景**：矩阵、螺旋遍历等

**关键点**：
- 边界控制
- 方向数组的使用

---

## 双指针与滑动窗口

### 模式1：同向双指针

**适用场景**：排序数组中的配对问题、窗口问题

**关键点**：
- 快指针负责探索，慢指针负责记录

### 模式2：相向双指针

**适用场景**：有序数组的两数之和、回文判断

**关键点**：
- 排序后使用
- 从两端向中间收缩

### 模式3：滑动窗口

**适用场景**：子数组/子字符串的最值问题

**关键点**：
- 窗口的大小和移动逻辑
- 如何维护窗口内的信息

**模板**：

```java
int left = 0, right = 0;
while (right < nums.length) {
    // 扩大窗口
    window.add(nums[right]);
    right++;

    while (不满足条件) {
        // 缩小窗口
        window.remove(nums[left]);
        left++;
    }
    // 更新答案
}
```

---

## 哈希表

### 模式1：查找补数

**适用场景**：两数之和类型问题

**关键点**：
- 边遍历边查找
- 目标值 = target - 当前值

### 模式2：去重

**适用场景**：判断元素是否重复

**关键点**：
- 使用 Set 记录已出现的元素

### 模式3：统计频率

**适用场景**：需要统计元素出现次数

**关键点**：
- 使用 Map 记录频次

---

## 链表

### 模式1：虚拟头节点

**适用场景**：需要修改链表头节点的操作

**关键点**：
- 统一处理头节点和普通节点
- 避免空指针异常

**模板**：

```java
ListNode dummy = new ListNode(0);
dummy.next = head;
ListNode curr = dummy;
while (curr.next != null) {
    // 处理 curr.next
}
return dummy.next;
```

### 模式2：快慢指针

**适用场景**：找中点、判断环

**关键点**：
- 快指针每次走两步，慢指针每次走一步
- 快指针到末尾时，慢指针在中点

---

## 栈与队列

### 模式1：单调栈

**适用场景**：下一个更大/更小元素

**关键点**：
- 维护单调性
- 栈中存的是索引或元素

### 模式2：括号匹配

**适用场景**：括号序列的合法性判断

**关键点**：
- 左括号入栈，右括号出栈

---

## 二叉树

### 模式1：递归遍历

**适用场景**：树的各种遍历、路径问题

**关键点**：
- 确定递归终止条件
- 确定单层递归逻辑

### 模式2：BFS 层序遍历

**适用场景**：按层访问节点

**关键点**：
- 使用队列
- 记录每层的节点数量

**模板**：

```java
Queue<TreeNode> queue = new LinkedList<>();
queue.offer(root);
while (!queue.isEmpty()) {
    int size = queue.size();
    for (int i = 0; i < size; i++) {
        TreeNode node = queue.poll();
        // 处理当前节点
        if (node.left != null) queue.offer(node.left);
        if (node.right != null) queue.offer(node.right);
    }
}
```

---

## 二分查找

### 模式1：标准二分

**适用场景**：在有序数组中查找目标值

**关键点**：
- 区间的开闭（左闭右闭最常用）
- 中间值计算避免溢出

**模板**：

```java
int left = 0, right = nums.length - 1;
while (left <= right) {
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] < target) {
        left = mid + 1;
    } else {
        right = mid - 1;
    }
}
return -1;
```

---

## 贪心算法

### 模式1：区间调度

**适用场景**：区间重叠、会议室问题

**关键点**：
- 按结束时间排序
- 选择不重叠的区间

### 模式2：跳跃游戏

**适用场景**：能否到达、最少跳跃次数

**关键点**：
- 维护当前能到达的最远位置

---

## 回溯算法

### 模式1：组合/排列

**适用场景**：从数组中选取元素

**关键点**：
- 回溯三要素：路径、选择列表、结束条件
- 去重（used 数组或排序）

**模板**：

```java
void backtrack(路径, 选择列表) {
    if (满足结束条件) {
        result.add(新路径);
        return;
    }

    for (选择 in 选择列表) {
        做选择;
        backtrack(路径, 选择列表);
        撤销选择;
    }
}
```

### 模式2：子集

**适用场景**：所有可能的子集

**关键点**：
- 每个元素都有选或不选两种选择

---

## 动态规划

### 模式1：背包问题

**适用场景**：有限容量下的最优选择

**关键点**：
- 定义 dp 数组含义
- 确定状态转移方程

### 模式2：最长递增子序列

**适用场景**：子序列的最值问题

**关键点**：
- dp[i] 表示以 i 结尾的最长递增子序列长度

### 模式3：打家劫舍

**适用场景**：相邻元素不能同时选择

**关键点**：
- 状态转移：选或不选当前元素

**模板**：

```java
int[] dp = new int[n];
dp[0] = 初始值;
for (int i = 1; i < n; i++) {
    dp[i] = max(选择当前值, 不选择当前值);
}
return dp[n - 1];
```

---

*本文档持续更新中...*
